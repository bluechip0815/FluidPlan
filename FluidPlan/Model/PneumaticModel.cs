using FluidPlan.Dto;
using FluidPlan.Model;

namespace FluidSimu
{
    public class PneumaticModel
    {
        /// <summary>
        /// Determines the simulation mode.
        /// If true, elements respond to direct control.
        /// If false, elements follow their pre-loaded schedules.
        /// </summary>
        public bool IsInteractive { get; set; } = false;
        /// <summary>
        /// Pneumatic elements 
        /// </summary>
        private readonly List<IPneumaticElement> _elements = new();
        // Expose elements for the Logger
        public List<IPneumaticElement> Elements => _elements;
        /// <summary>
        /// Network connections
        /// </summary>
        private readonly Dictionary<int, Junction> _junctions = new();
        public IReadOnlyDictionary<int, Junction> Junctions => _junctions;         
        public double DeltaT { get; private set; } = 1.0;
        public double LastMaxPressureDelta { get; private set; } = double.PositiveInfinity;
        public string ModelName { get; private set; } = "";
        /// <summary>
        /// Charge data generated by flow
        /// </summary>
        private double[] _chargeAccumulator = Array.Empty<double>();
        public void AddCharge(int index, double dQ)
        {
            if (index >= 0 && index < _chargeAccumulator.Length)
            {
                _chargeAccumulator[index] += dQ;
            }
        }
        public double GetCharge(int index)
        {
            if (index >= 0 && index < _chargeAccumulator.Length)
            {
                return _chargeAccumulator[index];
            }
            return 0.0;
        }
        // Fügen Sie dies oben in die PneumaticModel.cs Klasse ein
        //private readonly HashSet<(int, int)> _processedPairs = new();
        public static PneumaticModel FromDto(SimulationModelDto dto)
        {
            var model = new PneumaticModel();
            model.ModelName = dto.ModelName;
            int chargeIndex = 0;
            int idIndex = 0;
            foreach (var e in dto.Elements)
            {
                // Erstelle das Element mit seiner fortlaufenden ID
                IPneumaticElement element = e.Type.ToLower() switch
                {
                    "pipe" => new PipeElement(e, idIndex, chargeIndex),
                    "valve" => new ValveElement(e, idIndex, chargeIndex),
                    "throttle" => new ThrottleElement(e, idIndex, chargeIndex),
                    "checkvalve" => new CheckValveElement(e, idIndex, chargeIndex),
                    "tank" => new TankElement(e, idIndex, chargeIndex),
                    "exhaust" => new SupplyElement(e, idIndex, chargeIndex, true),
                    "supply" => new SupplyElement(e, idIndex, chargeIndex, false),
                    "epu" => new EpuElement(e, idIndex, chargeIndex),
                    "regulator" => new PressureRegulatorElement(e, idIndex, chargeIndex),
                    _ => throw new NotSupportedException($"Unknown element type {e.Type}")
                };
                model._elements.Add(element);
                if (element is ValveElement)
                {
                    chargeIndex += 2; // Ventile belegen ZWEI Plätze
                }
                else
                {
                    chargeIndex += 1;
                }
                idIndex++;
            }
            model._chargeAccumulator = new double[chargeIndex];

            // 1. Erstelle für jeden Eintrag in "connections" einen Junction-Knotenpunkt
            foreach (var connectionKey in dto.Connections.Keys)
            {
                if (int.TryParse(connectionKey, out int junctionId))
                {
                    model._junctions[junctionId] = new Junction(junctionId);
                }
            }
            // 2. Gehe alle Elemente durch und weise ihre Ports den Junctions zu
            foreach (var element in model._elements)
            {
                // Finde heraus, mit welchen Junctions dieses Element verbunden ist
                (int j1, int j2) = FindJunctionsForElement(dto, element.Name, dto.Elements);

                element.SetConnectors(j1, j2); // Speichert die Junction-IDs im Element

                if (j1 != -1 && model._junctions.TryGetValue(j1, out var junction1))
                {
                    junction1.AddConnection(new Connection(element, 1));
                }
                if (j2 != -1 && model._junctions.TryGetValue(j2, out var junction2))
                {
                    junction2.AddConnection(new Connection(element, 2));
                }
            }

            // --- VALIDATION LOGIC ---
            ModelValidation.DumpModel(model._elements, model.ModelName);
            ModelValidation.DumpJunctions(model.Junctions);
            ModelValidation.ValidateModel(model, dto);
         
            return model;
        }
        // In der Klasse PneumaticModel

        private static (int, int) FindJunctionsForElement(SimulationModelDto dto, string elementName, List<ElementDto> allElements)
        {
            int port1Junction = -1;
            int port2Junction = -1;

            var elementDto = allElements.FirstOrDefault(e => e.Name.Equals(elementName, StringComparison.OrdinalIgnoreCase));
            string elementType = elementDto?.Type.ToLower() ?? "";

            foreach (var entry in dto.Connections)
            {
                foreach (var connectionString in entry.Value)
                {
                    var parts = connectionString.Split('.');
                    if (parts.Length > 1 && parts[0].Trim().Equals(elementName, StringComparison.OrdinalIgnoreCase))
                    {
                        int.TryParse(entry.Key, out int junctionId);
                        string portIdentifier = parts[1].Trim().ToLower();
                        int portNumber = 0;

                        // --- FINALE, PRÄZISIERTE ÜBERSETZUNGS-LOGIK ---
                        if (elementType == "checkvalve" ||
                            elementType == "regulator" ||
                            elementType == "epu")
                        {
                            // Nur für CheckValve: Übersetze "In" und "Out"
                            // Alternativ 1 und 2
                            if (portIdentifier == "in" || portIdentifier=="1") portNumber = 1;
                            else if (portIdentifier == "out" || portIdentifier=="2") portNumber = 2;
                        }
                        else
                        {
                            // Für ALLE anderen Elemente (Valve, Throttle, Pipe, etc.)
                            // wird die numerische Port-ID erwartet.
                            int.TryParse(portIdentifier, out portNumber);
                        }

                        if (portNumber == 1) port1Junction = junctionId;
                        if (portNumber == 2) port2Junction = junctionId;
                    }
                }
            }
            return (port1Junction, port2Junction);
        }
        public double ApplyProfile(ExecutionProfileDto profile)
        {
            bool hasValve = false;
            bool hasEpu = false;

            Console.WriteLine("\nApplying execution profile and validating schedules...");

            foreach (var element in _elements)
            {
                if (element is EpuElement epu)
                {
                    hasEpu = true;
                    // Try to get the timeline for the EPU by its name.
                    if (profile.EpuTimelines.TryGetValue(epu.Name, out var timeline))
                    {
                        // The timeline exists, now check if it's valid.
                        if (timeline == null || timeline.Count == 0)
                        {
                            // Case 1: The timeline is empty.
                            Console.ForegroundColor = ConsoleColor.Yellow;
                            Console.WriteLine($"WARNING: The timeline for EPU '{epu.Name}' is empty. It will remain at its initial pressure.");
                            Console.ResetColor();
                        }
                        else if (timeline.All(e => Math.Abs(e.TargetPressure) < 1e-9))
                        {
                            // Case 2: The timeline exists but all values are zero. THIS IS THE KEY CHECK.
                            Console.ForegroundColor = ConsoleColor.Red;
                            Console.WriteLine($"ERROR: The timeline for EPU '{epu.Name}' was found, but all target pressures are zero.");
                            Console.WriteLine("         This is likely caused by a typo in the execution profile JSON.");
                            Console.WriteLine("         HINT: Please ensure you are using '\"targetPressure\"' as the property name.");
                            Console.ResetColor();
                        }
                        else
                        {
                            // The timeline is valid. Set the schedule.
                            Console.WriteLine($"  - Valid schedule found and applied for EPU '{epu.Name}'.");
                            epu.SetSchedule(timeline);
                        }
                    }
                    else
                    {
                        // Case 3: No timeline found for this EPU at all.
                        Console.ForegroundColor = ConsoleColor.Yellow;
                        Console.WriteLine($"WARNING: EPU '{epu.Name}' exists but has no timeline in the execution profile. It will remain at its initial pressure.");
                        Console.ResetColor();
                    }
                }
                // If element is Valve, look for schedule
                else if (element is ValveElement valve)
                {
                    hasValve = true;
                    if (profile.ValveTimelines.TryGetValue(valve.Name, out var timeline))
                    {
                        valve.SetSchedule(timeline);
                    }
                }
            }

            double lastEvent = 0;

            if (hasValve)
                lastEvent = profile.GetLastValveEventTime();

            if (hasEpu)
            {
                double dt = profile.GetLastEpuEventTime();
                if (dt > lastEvent)
                    lastEvent = dt;
            }
            return lastEvent;
        }
        public double CurrentTime { get; private set; } = 0;
        public void Reset(double dt)
        {
            DeltaT = dt;
            CurrentTime = 0;
        }

        public void Execute()
        {
            // === PHASE 1: INTERNE ZUSTÄNDE AKTUALISIEREN ===
            // (z.B. Ventilöffnungsgrad basierend auf Zeitplan berechnen)
            foreach (var element in _elements)
            {
                element.UpdateInternalState(this);
            }

            // === PHASE 2: KNOTENDRÜCKE LÖSEN (SOLVER) ===
            // Das ist der neue Kernschritt. Jeder Knotenpunkt findet seinen
            // stabilen Druck für diesen Zeitschritt.
            foreach (var junction in _junctions.Values)
            {
                junction.SolvePressure(this);
            }

            // === PHASE 3: FINALE FLÜSSE BERECHNEN & LADUNG VERTEILEN ===
            Array.Clear(_chargeAccumulator, 0, _chargeAccumulator.Length);

            foreach (var junction in _junctions.Values)
            {
                // Da der Knotendruck jetzt bekannt ist, können wir die finalen
                // Ströme berechnen und die Ladungsänderungen zuweisen.
                foreach (var connection in junction.ConnectedPorts)
                {
                    double pElement = GetPressureFromPort(connection.Item, connection.Port);
                    double pJunction = junction.Pressure;
                    double area = connection.Item.Area;

                    // Berechne den finalen geglätteten Fluss...
                    double smoothedFlow = FlowPhysics.ComputeSmoothedVolumeFlow(
                        pElement,
                        pJunction,
                        area,
                        connection.Item.FlowCoefficient,
                        connection.LastVolumeFlow,
                        DeltaT
                    );
                    // ... und speichere ihn für den nächsten Zeitschritt!
                    connection.LastVolumeFlow = smoothedFlow;

                    double pSource = (smoothedFlow > 0) ? pElement : pJunction;
                    double chargeFlow = FlowPhysics.VolumeFlowToChargeFlow(smoothedFlow, pSource);

                    // Ladungsänderung an den richtigen Port des Elements senden
                    AddChargeToPort(connection.Item, connection.Port, -chargeFlow * DeltaT);
                }
            }

            // Interne Flüsse für Ventile berechnen
            foreach (var valve in _elements.OfType<ValveElement>())
            {
                valve.CalculateInternalFlow(this);
            }

            // === PHASE 4: DRÜCKE IN ELEMENTEN AKTUALISIEREN ===
            double maxDelta = 0.0;
            foreach (var element in _elements)
            {
                double delta = element.CalcPressure(this);
                if (delta > maxDelta)
                    maxDelta = delta;
            }

            LastMaxPressureDelta = maxDelta;
            CurrentTime += DeltaT;
        }

        // Private Hilfsfunktionen (können auch statisch sein)
        private static double GetPressureFromPort(IPneumaticElement element, int port)
        {
            if (element is ValveElement v && port == 2) return v.PressurePort2;
            return element.Pressure;
        }

        private void AddChargeToPort(IPneumaticElement element, int port, double chargeDelta)
        {
            int index = (element is ValveElement v && port == 2) ? v.ChargeIndex + 1 : element.ChargeIndex;
            AddCharge(index, chargeDelta);
        }
    }
}