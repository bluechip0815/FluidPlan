(*====================================================================
    FUNCTION_BLOCK FB_PneumaticModel
    Description: Orchestrates the entire pneumatic simulation.
                 It holds the state of all elements and manages the
                 two-phase execution (Flow Calc, Pressure Update).
====================================================================*)
FUNCTION_BLOCK FB_PneumaticModel
VAR_INPUT
    bEnable             : BOOL;     
    bExecuteStep        : BOOL;     
    fDeltaT             : LREAL := 0.001; 
END_VAR
VAR_IN_OUT
    arElementConfigs    : ARRAY[*] OF ST_Element_Config;
    arConnections       : ARRAY[*] OF ST_Connection;
    arControlInputs     : ARRAY[*] OF LREAL; 
    arMonitoredPressures: ARRAY[*] OF LREAL; 
END_VAR
VAR
    // Internal State
    _arElementStates    : ARRAY[1..GVL.MAX_ELEMENTS] OF ST_Element_State;
    _arFlowMemory       : ARRAY[1..GVL.MAX_CONNECTIONS] OF LREAL; // For smoothing
    _fCurrentSimTime    : LREAL;
    
    // Iterators
    i, j : INT;
    iElA, iElB : INT;
    
    // Physics Helpers
    fAreaEff : LREAL;
    fFlowRaw, fFlowSmooth : LREAL;
    fSourcePressure : LREAL;
    fChargeDelta : LREAL;
    fAlphaSmooth : LREAL;
    
    // Triggers
    _trigExecuteStep    : R_TRIG;
    _trigEnable         : R_TRIG;
    
    // Element References (Helpers)
    _cfg : POINTER TO ST_Element_Config;
    _state : POINTER TO ST_Element_State;
END_VAR

// --- LOGIC START ---

// Initialize
_trigEnable(CLK := bEnable);
IF _trigEnable.Q THEN
    _InitializeStates();
END_IF;

IF NOT bEnable THEN RETURN; END_IF;

// Execute Step
_trigExecuteStep(CLK := bExecuteStep);
IF _trigExecuteStep.Q THEN

    // --------------------------------------------------------
    // PHASE 1: UPDATE ELEMENT STATES (Valves & Actuators)
    // --------------------------------------------------------
    FOR i := 1 TO GVL.MAX_ELEMENTS DO
        // Skip unused elements
        IF arElementConfigs[i].eType = E_ElementType.None THEN CONTINUE; END_IF;
        
        _cfg := ADR(arElementConfigs[i]);
        _state := ADR(_arElementStates[i]);
        
        // Reset net flow accumulator for this step
        _state^.fNetVolumeFlow := 0.0;
        
        CASE _cfg^.eType OF
            // --- VALVE LOGIC ---
            E_ElementType.Valve, E_ElementType.Throttle:
                // Map Input (0.0 - 1.0) to Target
                // Simple Ramp implementation for transition
                // Delta = Rate * Time. Rate approx 1.0 / 0.05s = 20.0 units/s
                IF arControlInputs[i] > _state^.fCurrentOpening THEN
                    _state^.fCurrentOpening := _state^.fCurrentOpening + (20.0 * fDeltaT);
                    IF _state^.fCurrentOpening > 1.0 THEN _state^.fCurrentOpening := 1.0; END_IF;
                ELSIF arControlInputs[i] < _state^.fCurrentOpening THEN
                    _state^.fCurrentOpening := _state^.fCurrentOpening - (20.0 * fDeltaT);
                    IF _state^.fCurrentOpening < 0.0 THEN _state^.fCurrentOpening := 0.0; END_IF;
                END_IF;
            
            // --- EPU LOGIC ---
            E_ElementType.EPU:
                // Control input is target pressure in Bar
                _state^.fTargetPressure := arControlInputs[i];
                
                // Simple PT1 approximation for EPU pressure generation
                // P_new = P_old + (dt/T) * (Target - P_old)
                IF _cfg^.stEpuParams.fTimeConstant > 0 THEN
                   _state^.fPressure := _state^.fPressure + 
                        (fDeltaT / _cfg^.stEpuParams.fTimeConstant) * 
                        (_state^.fTargetPressure - _state^.fPressure);
                END_IF;
        END_CASE;
    END_FOR;

    // --------------------------------------------------------
    // PHASE 2: CALCULATE FLOWS (Connections)
    // --------------------------------------------------------
    FOR i := 1 TO GVL.MAX_CONNECTIONS DO
        iElA := arConnections[i].iElementA;
        iElB := arConnections[i].iElementB;
        
        // Skip empty connections
        IF iElA = 0 OR iElB = 0 THEN CONTINUE; END_IF;
        
        // 1. Determine Effective Area
        // Start with connection area of Element A
        fAreaEff := arElementConfigs[iElA].fConnectionArea;
        
        // If connected to a Valve, scale area by opening
        IF arElementConfigs[iElA].eType = E_ElementType.Valve THEN
            fAreaEff := fAreaEff * _arElementStates[iElA].fCurrentOpening;
        END_IF;
        IF arElementConfigs[iElB].eType = E_ElementType.Valve THEN
             // Take the smaller restriction if both are valves (series)
             // or restrict if B is the valve
            fAreaEff := MIN(fAreaEff, arElementConfigs[iElB].fConnectionArea * _arElementStates[iElB].fCurrentOpening);
        END_IF;

        // 2. Calculate Raw Volume Flow
        fFlowRaw := F_CalculateVolumeFlow(
            fPA := _arElementStates[iElA].fPressure,
            fPB := _arElementStates[iElB].fPressure,
            fArea := fAreaEff,
            fCd := 1.0 // Assumed Cd=1.0 per connection for simplicity
        );
        
        // 3. Apply Smoothing (Low Pass Filter)
        // Alpha = 1 - exp(-dt / T_smooth) roughly. T_smooth ~ 5ms
        fAlphaSmooth := 0.2; // Tunable
        fFlowSmooth := (fAlphaSmooth * fFlowRaw) + ((1.0 - fAlphaSmooth) * _arFlowMemory[i]);
        _arFlowMemory[i] := fFlowSmooth; // Store for next step
        
        // 4. "Charge" Flow Calculation (C# Logic: Q_charge = Q_vol * P_source)
        // Determine Source Pressure (where flow comes from)
        IF fFlowSmooth > 0 THEN
             fSourcePressure := _arElementStates[iElA].fPressure;
        ELSE
             fSourcePressure := _arElementStates[iElB].fPressure;
        END_IF;
        
        // Avoid zero pressure locking the system (Vacuum handling)
        IF fSourcePressure < 0.001 THEN fSourcePressure := 0.001; END_IF;

        // Calculate Charge Delta (dCharge = Q_vol * P_src * dt)
        fChargeDelta := fFlowSmooth * fSourcePressure * fDeltaT;
        
        // 5. Distribute Charge (Accumulate to Elements)
        // Subtractive from A (leaves A), Additive to B (enters B)
        // We store this temporarily in fNetVolumeFlow variable of the state 
        // to act as the "Net Charge Delta" for Phase 3.
        _arElementStates[iElA].fNetVolumeFlow := _arElementStates[iElA].fNetVolumeFlow - fChargeDelta;
        _arElementStates[iElB].fNetVolumeFlow := _arElementStates[iElB].fNetVolumeFlow + fChargeDelta;
        
    END_FOR;

    // --------------------------------------------------------
    // PHASE 3: UPDATE PRESSURES (Integration)
    // --------------------------------------------------------
    FOR i := 1 TO GVL.MAX_ELEMENTS DO
        // Skip unused
        IF arElementConfigs[i].eType = E_ElementType.None THEN CONTINUE; END_IF;
        
        _cfg := ADR(arElementConfigs[i]);
        _state := ADR(_arElementStates[i]);
        
        // Elements with infinite volume (Supply, Exhaust) or Self-Regulated (EPU) 
        // do not change pressure via flow integration.
        IF _cfg^.eType = E_ElementType.Supply OR 
           _cfg^.eType = E_ElementType.EPU THEN
             // Pressure is maintained by definition or internal control
             // Just update monitoring
             arMonitoredPressures[i] := _state^.fPressure;
             CONTINUE;
        END_IF;
        
        // Calculate New Pressure
        // P_new = (P_old * Volume + dCharge) / Volume
        // dCharge was stored in fNetVolumeFlow in Phase 2
        
        IF _cfg^.fVolume > 1.0E-9 THEN
            // Calculate current total charge
            VAR 
                fCurrentCharge : LREAL;
                fNewCharge : LREAL;
            END_VAR
            
            fCurrentCharge := _state^.fPressure * _cfg^.fVolume;
            fNewCharge := fCurrentCharge + _state^.fNetVolumeFlow;
            
            // Update Pressure
            _state^.fPressure := fNewCharge / _cfg^.fVolume;
            
            // Safety: No negative pressure (Vacuum limit)
            IF _state^.fPressure < 0.0 THEN _state^.fPressure := 0.0; END_IF;
        END_IF;
        
        // Update Output
        arMonitoredPressures[i] := _state^.fPressure;
        
    END_FOR;
    
    // Increment Sim Time
    _fCurrentSimTime := _fCurrentSimTime + fDeltaT;
    
END_IF;

END_FUNCTION_BLOCK

(*====================================================================
    METHOD _InitializeStates (Internal)
    Description: Reset simulation to config values
====================================================================*)
METHOD PRIVATE _InitializeStates
VAR
    k : INT;
END_VAR

FOR k := 1 TO GVL.MAX_ELEMENTS DO
    IF arElementConfigs[k].eType <> E_ElementType.None THEN
        _arElementStates[k].fPressure := arElementConfigs[k].fInitialPressure;
        _arElementStates[k].fCurrentOpening := 0.0; // Valves closed by default
        _arElementStates[k].fNetVolumeFlow := 0.0;
        
        // Output initial
        arMonitoredPressures[k] := _arElementStates[k].fPressure;
    END_IF;
END_FOR;

// Clear flow memory
MEMSET(ADR(_arFlowMemory), 0, SIZEOF(_arFlowMemory));
_fCurrentSimTime := 0.0;

END_METHOD